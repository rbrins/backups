#+TITLE: Backup Script with Literate Programming
#+AUTHOR: Russell Brinson
#+DATE: [2023-08-06 Sun]

* Overview

Literate programming to be able to test individual steps in a backup or run all at once by tangling everything (possible exporting for cron jobs later)

* Modules and Argument Parsing

#+BEGIN_SRC python :tangle yes
import yaml
import argparse
import os

parser = argparse.ArgumentParser(prog='Simple Backups')
parser.add_argument('-b', '--backup-file', required=False, default=".backups.yml")

args = parser.parse_args()

backup_yaml = args.backup_file

userHomePath = os.path.expanduser('~')
#+END_SRC

* Create files to backup list from config file

** Methods for generating the lists
#+BEGIN_SRC python :tangle yes
def expandPath(path):
    """Adding the home directory path if a  ~ is present"""
    if path[0] == "~":
        return userHomePath + path[1:]
    return path

def addFullPath(child, directory):
    """Returns full path of child in a directory"""
    return (directory + "/" + child)
          
def getAllSubContents(directory):
    """Recurses through a directory for all subcontents"""
    allSubContents = []
    for child in os.listdir(directory):
        fullPath = addFullPath(child, directory)
        if os.path.isdir(fullPath) == True:
            #print(fullPath)
            allSubContents.extend(getAllSubContents(fullPath))
        elif os.path.isfile(fullPath):
            allSubContents.append(directory + "/" + child)
    return allSubContents

def flatten(list1):
    """Takes list of lists and converts to single flat list"""
    flat_list = []
    for sublist in list1:
        for item in sublist:
            flat_list.append(item)
    return flat_list

#def listAllContents(homePath_BackupConfig):
#    """Returns list of all child contents of the backup list"""
#    # this expects the backup list to have full paths generated
#    allContentsList = []
#    for path in homePath_BackupConfig:         
#        try:
#            allContentsList.extend(getAllSubContents(path))
#        except Exception as e:
#            print(e)
#    return allContentsList

#+END_SRC

** Methods for comparing the lists

** Creating the file backup file list (no directories)

#+BEGIN_SRC python :tangle yes

#+END_SRC



* Reading the Backup Configuration

** Sample Yaml File
#+BEGIN_SRC yaml
---
include:
  - "dir1"
  - "dir2/subdir"
  - "dir3/specific_file"

exclude:
  - "dir4"
  - "dir1/subdir1"
  - "dir1/specific_file"

last_backup: timestamp
backup_type: "incremental" or "full"
#+END_SRC

** Reading the .backup.yml file
#+BEGIN_SRC python :tangle yes
with open(backup_yaml, 'r') as config_file:
    backup_config = yaml.safe_load(config_file)

try:
    includes_Paths = list(map(expandPath, backup_config['include']))
    includesAllFiles = flatten(list(map(getAllSubContents, includes_Paths)))

except:
    print("[E] No include section within backup yaml file, exiting")
    exit(1)

try:
    excludes_Paths = list(map(expandPath, backup_config['exclude']))
    # This is where the comparison can be created
except:
    print("[W] No exclude section within backup yaml file, continuing")
#+END_SRC

** backup_config['include'] is a list
#+BEGIN_SRC python :tangle no
['~/.ssh', '~/.dotfiles', '~/org', '~/Documents', '~/Pictures', '~/projects']
<class 'list'>
#+END_SRC


* Full backup type selection
If the full backup type is selected then I'm just going to create a file list of what to include, then remove anything excluded.

#+BEGIN_SRC python :tangle yes
if(backup_config['backup_type'] == "full"):
    print("Proceeding to full backup")


#allContents = listAllContents(includes_Paths)

with open("./.tmpAllContentsList","w") as tmpList:
    for item in includesAllFiles:
        tmpList.write(item + "\n")
#+END_SRC
