#+TITLE: Backup Script with Literate Programming
#+AUTHOR: Russell Brinson
#+DATE: [2023-08-06 Sun]

* Overview

Literate programming to be able to test individual steps in a backup or run all at once by tangling everything (possible exporting for cron jobs later)

* Modules and Argument Parsing

#+BEGIN_SRC python :tangle yes
import yaml
import argparse
import os

parser = argparse.ArgumentParser(prog='Simple Backups')
parser.add_argument('-b', '--backup-file', required=False, default=".backups.yml")

args = parser.parse_args()

backup_yaml = args.backup_file

userHomePath = os.path.expanduser('~')
#+END_SRC

* Create files to backup list from config file

** Methods for generating the lists
#+BEGIN_SRC python :tangle yes
def expandPath(path):
    """Adding the home directory path if a  ~ is present"""
    if path[0] == "~":
        return userHomePath + path[1:]
    return path

def addFullPath(child, directory):
    """Returns full path of child in a directory"""
    return (directory + "/" + child)
          
def getAllSubContents(directory):
    """Recurses through a directory for all subcontents"""
    allSubContents = []
    for child in os.listdir(directory):
        fullPath = addFullPath(child, directory)
        if os.path.isdir(fullPath) == True:
            #print(fullPath)
            allSubContents.extend(getAllSubContents(fullPath))
        elif os.path.isfile(fullPath):
            allSubContents.append(directory + "/" + child)
    return allSubContents

def flatten(list1):
    """Takes list of lists and converts to single flat list"""
    flat_list = []
    for sublist in list1:
        for item in sublist:
            flat_list.append(item)
    return flat_list


#+END_SRC

** Methods for comparing the lists
- list method ~remove~ should remove an item by its value
  - only removes the first occurence 
  - error if no instance
- using sets can subtract from each other
Will make sure that each list is only unique valuies, which allows us to use remove easily.

#+BEGIN_SRC python :tangle yes
def removeListFromList(list1, list2):
    return list(set(list1) - set(list2))
#+END_SRC


* Reading the Backup Configuration
** Sample Yaml File
#+BEGIN_SRC yaml
---
include:
  - "dir1"
  - "dir2/subdir"
  - "dir3/specific_file"

exclude:
  - "dir4"
  - "dir1/subdir1"
  - "dir1/specific_file"

last_backup: timestamp
backup_type: "incremental" or "full"
#+END_SRC

** backup_config['include'] is a list
sample output of what the ~backup_config['include']~ value contains
#+BEGIN_SRC python :tangle no
['~/.ssh', '~/.dotfiles', '~/org', '~/Documents', '~/Pictures', '~/projects']
<class 'list'>
#+END_SRC

** Reading the .backup.yml file
#+BEGIN_SRC python :tangle yes
with open(backup_yaml, 'r') as config_file:
    backup_config = yaml.safe_load(config_file)

try:
    includes_Paths = list(map(expandPath, backup_config['include']))
    includesAllFiles = flatten(list(map(getAllSubContents, includes_Paths)))

except:
    print("[E] No include section within backup yaml file, exiting")
    exit(1)


try:
    excludes_Paths = list(map(expandPath, backup_config['exclude']))
    excludesAllFiles = flatten(list(map(getAllSubContents, excludes_Paths)))
    finalAllFiles = removeListFromList(includesAllFiles, excludesAllFiles)
except:
    print("[W] No exclude section within backup yaml file, continuing")
    # defaulting to includes only
    finalAllFiles = includesAllFiles
#+END_SRC

** Create text file with list of all files

#+BEGIN_SRC python :tangle yes
with open("./.tmpAllContentsList","w") as tmpList:
    for item in finalAllFiles:
        tmpList.write(item + "\n")
#+END_SRC

* Full backup type selection
If the full backup type is selected then I'm just going to create a file list of what to include, then remove anything excluded.

#+BEGIN_SRC python :tangle yes
if(backup_config['backup_type'] == "full"):
    print("Proceeding to full backup")



#+END_SRC
